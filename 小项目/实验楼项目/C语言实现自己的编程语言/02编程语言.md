# 编程语言

### 一、课程简介

#### 1.1 实验简介

编程语言很像实际的语言，它也有自己的结构，一些规则，它指导着什么是对的，什么是错的。当我们学习自然语言的时候，我们无意识的学习了这些规则，同样我们在学习编程语言的时候，我们可以利用这些规则去理解其他人写的代码， 生成自己的代码。

#### 1.2 实验知识点

- 解析
- 正则表达式
- 波兰表达式

#### 1.3 实验环境

- Xfce 终端
- GCC
- Gedit

#### 1.4 适合人群

本课程适合有 C 语言基础，想做练手项目的同学，可以有效的学习`mpc` 库的安装使用，正则表达式，如何来解析我们的代码相关知识，做一些有趣的事情。

#### 1.5 代码获取

你可以通过下面命令将本课程里的所有源代码下载到实验楼环境中，作为参照对比进行学习。

```bash
wget http://labfile.oss.aliyuncs.com/courses/670/doge_code.c
wget http://labfile.oss.aliyuncs.com/courses/670/parsing.c
```

**请尽量按照实验步骤自己写出 C 语言程序，请确认文件保存在对应的目录下。**

### 二、实验步骤

先来看一个例子，通过这个例子来引入我们的问题：

> ```
> The cat walked on the carpet.
> ```

使用英语的规则，名词 cat 可以通过 and 替换为两个名词：

> ```
> The cat and dog walked on carpet.
> ```

每一段话的名词依然可以替换为其他的名词组合：

> ```
> The cat and mouse and dog walked on the carpet.
> The white cat and black dog walked on the carpet
> ```

在我们的 C\C++ 语言中也有类似的例子，`if` 语句体内包含了一些新的语句，这些新的语句里面又可以包含 `if` ：

> ```
> if (x>5) {return x;}
> if (x>5) {if(x>10) {return x;} }
> ```

为了编写我们的 Lispy 语言，需要了解一下语法。我们需要编写一个便于阅读的语法规则，并且能够通过它来判断输入是否合法。而且我们可以构建结构化的内在表示，这将使我们的语言更容易使用，更好的执行计算任务，这个任务就是我们要做的一件事--**解析**。

我们可以通过 `mpc` 库来达到这个任务。

#### 2.1 安装 mpc 库

在我们开始之后的学习时，先了解一下安装 `mpc` 的内容，我们需要在头文件中包含 `mpc` 的库，并在编译时链接到 `mpc` 库，就像我们之前学习 `readline` 一样，我们从 [mpc repo](http://github.com/orangeduck/mpc) 上下载源代码，然后将放入我们的代码文件夹即可。

```
cd ~
wget http://labfile.oss.aliyuncs.com/courses/670/mpc-master.zip
unzip mpc-master.zip
cd mpc-master
```

在文件夹里中 examples 和 tests ，为了可以使用它，我们需要在 Makefile 中加上 `-std=c99` ,因为我们环境里默认的 gcc 已经不是那个版本了，所以需要指定。使用 VIM 修改 Makefile 文件，在 CFLAGS 行的末尾添加 `-std=c99`：

```bash
vim Makefile
```

![2-2.1-1](https://doc.shiyanlou.com/document-uid59274labid2174timestamp1476095208726.png)

然后保存退出，运行 `make`（第一次运行可能要等待一会），运行成功后截图如下：

![2-2.1-2](https://doc.shiyanlou.com/document-uid59274labid2174timestamp1476095215463.png)

#### 2.2 解析器的组合

`mpc` 是一个组合的解析器库，我们可以通过它构建我们的语法程序，使用这个库可以让我们很容易完成构建自己的解析器。很多的解析器库可以让你写一个像普通语法的句子，但是在一些情况下表现并不好。而 `mpc` 库可以让我们写很像普通语法的句子，我们都可以用特殊的符号来写语法。

#### 2.3 编码的语法

我们怎么利用 `mpc` 库可以让语法像 [the language of Shiba Inu](http://knowyourmeme.com/memes/doge) ,或者叫 `Doge` 。这个语言定义如下：

> 形容词比如是 'wow'，'many'，'such' 名词比如是 'lisp'，'language'，'c'，'book'，'build' 短语是由名词 + 形容词构成 一段 Doge 可以由 0 到多个短语构成

我们开始尝试定义形容词和名词，为了达到这个目的，我们创建了两个解析器，用 `mpc_parser_t*` ，并且我们用单词 `Adjective` 和 `Noun` 来表示。我们将使用函数 `mpc_or` 去创建一个解析器，它将包含一些功能。通过函数 `mpc_sym` 来初始化我们的字符串。试着理解下面的代码。

> ```c
> //建立解析器 Ajective 来认识这个描述
> mpc_parser_t* Ajective = mpc_or(4,
>     mpc_sym("wow"), mpc_sym("many"),
>     mpc_sym("so"), mpc_sym("such"));
> //建立解析器 'Noun' 去描述事物
> mpc_parser_t* Noun = mpc_or(5,
>     mpc_sym("lisp"), mpc_sym("language"),
>     mpc_sym("book"), mpc_sym("build"),
>     mpc_sym("c"));
> ```

```
定义短语可以参考现有的短语形式，我们需要使用函数 `mpc_and` ，它将指定一些必须的事物。随着我们输入  `Adjective` 和 `Noun` ，我们定义的解析器将调用 `mpcf_strfold` 和 `free` 函数，它们将描述如何加入或者删除这些解析器：

> ```
> mpc_parser_t* Phrase = mpc_and(2, mpcf_strfold, Adjective, Noue, free);
> ```
>

为了描述 `Doge` ,我们需要定义 0 个到多个必要的解析器，`mpc_many` 函数可以帮助我们做到这一点，这个函数还需要变量 `mpcf_strfold` 来描述结果是如何加在一起的：

> ```
> mpc_parser_t* Doge = mpc_many(mpcf_strfold, Phrase);
> ```
>

 通过构建解析器找到 0 个或多个其他的解析器，将会发生一些有趣事情。我们的 `Doge` 解析器可以接受任意长度输入。这就意味着它可以接受很长的输入，这里有一些输入例子 `Doge` 可以接受，正如我们在上一节发现的一样，我们已经使用了有限数量的重写规则来创建一个无限的语言：

> ```
> "wow book such language many lisp"
> "so c such build such language"
> "many build wow c"
> ""
> "wow lisp wow c many language"
> "so c"
> ```
>

如果我们更多的使用 `mpc` 库，就可以慢慢地构建一个很复杂的解析器，我们使用代码就更像语法。当然这不是一件简单的的任务， 通过 [mpc repository](http://github.com/orangeduck/mpc) 库可以找到很多的帮助信息，构建整个解析器。但是使用好这个函数库还是需要一定的理解能力，很好的操作能力。

**编写源程序 doge_code.c：**

​```c
#include "mpc.h"

int main(int argc, char** argv) {

  /* Build a parser 'Adjective' to recognize descriptions */
  mpc_parser_t* Adjective = mpc_or(4, 
    mpc_sym("wow"), mpc_sym("many"),
    mpc_sym("so"),  mpc_sym("such")
  );

  /* Build a parser 'Noun' to recognize things */
  mpc_parser_t* Noun = mpc_or(5,
    mpc_sym("lisp"), mpc_sym("language"),
    mpc_sym("book"), mpc_sym("build"), 
    mpc_sym("c")
  );
  
  mpc_parser_t* Phrase = mpc_and(2, mpcf_strfold, 
    Adjective, Noun, free);
  
  mpc_parser_t* Doge = mpc_many(mpcf_strfold, Phrase);

  /* Do some parsing here... */
  
  mpc_delete(Doge);
  
  return 0;  
}
gcc -std=c99 -Wall doge_code.c mpc.c -o doge_code -lreadline -lm 
```

因为没有输入和输出，所以看不到效果。

> 在这里，我们现在先不用担心编译和运行程序的事情，先确保理解背后的理论知识。

#### 2.4 自然语言

`mpc` 库让我们的语法更加的自然，比起 C，我们可以将我们的语法更贴近自然语言，在 `mpcf_strfold` 和 `free` 函数的帮助下，我们不用担心什么时候加入和丢弃输入，它们将自动帮助我们完成。

我们通过下面的操作重建之前的例子：

> ```
> #include "mpc.h"
> 
> int main(int argc, char** argv) {
> 
>   mpc_parser_t* Adjective = mpc_new("adjective");
>   mpc_parser_t* Noun      = mpc_new("noun");
>   mpc_parser_t* Phrase    = mpc_new("phrase");
>   mpc_parser_t* Doge      = mpc_new("doge");
> 
>   mpca_lang(MPCA_LANG_DEFAULT,
>     "                                           \
>       adjective : \"wow\" | \"many\"            \
>                 |  \"so\" | \"such\";           \
>       noun      : \"lisp\" | \"language\"       \
>                 | \"book\" | \"build\" | \"c\"; \
>       phrase    : <adjective> <noun>;           \
>       doge      : <phrase>*;                    \
>     ",
>     Adjective, Noun, Phrase, Doge);
> 
>   /* Do some parsing here... */
> 
>   mpc_cleanup(4, Adjective, Noun, Phrase, Doge);
>   
>   return 0;
> }
> ```

在这个语法规则下，我们代码看起来很好理解，另一个需要注意的是，这个进程分为了两个步骤，首先我们将使用 `mpc_new` ，接着我们使用 `mpca_lang` 。

> 这里我们使用的是 `include "mpc.h"` , 而不是 `include <mpc.h>` ，前者先从当前目录寻找相关的头文件，后者先从系统目录寻找相关的头文件。

`mpca_lang` 的第一个参数是选择标志，我们使用默认值即可，第二个是一个长点的字符串，它是指语法说明，包含了很多的重写规则。每一条规则都有左边的 `:` 和右边的 `;` 组成。特殊的符号定义的规则如下所示：

> ```
> "ab"    表示字符串 ab
> 'a'        表示字符 a
> 'a' 'b'    表示先有字符 a ,再有字符 b
> 'a' | 'b' 表示在字符 a 和 b 之间选择一个    
> 'a'*    表示有0个或多个a
> 'a'+    表示至少有一个a
> <abba>    表示规则 abba
> ```

使用上面的表可以验证我们之前的在代码所说的，现在来理解这些代码，可能有点困难，但是在你继续看下去，明白了之后，就会得心应手，知晓怎么操作了。

#### 2.5 波兰表达式

为了更好的使用 `mpc` 库， 我们将在 Lisp 上使用简单的数学表示法----波兰表达式来进行操作，它的运算符号在数字之前：

> ```
> 1 + 2 + 6                            is              + 1 2 6    
> 6 + (2 * 9)                            is                + 6 (* 2 9)    
> (10 * 2) / (4 + 2)                    is              / (* 10 2) (+ 4 2)
> ```

我们需要制定一个描述这个符号的语法，我们可以先描述文本，之后再来理解它。首先我们观察到在波兰表达式中先是运算符，之后再是数字或者其他的表达式。因此我们可以说一个程序由一个操作符，之后跟着其它的表达式或者数字组成，更正式的表示：

> ```
> Program         输入由操作符，一个或者多个表达式组成
> Expresssion     由一个数字或者 '(' 操作符+其它的表达式 ')'
> Operation         '+', '-', '*', 或者 '/'
> Number            由0-9数字组成，也可以用'-'来表示负数
> ```

#### 2.6 正则表达式

我们已经知道如何编码的大多数规则了，但是数字和程序可能会出错，因为其中可能包含了一些我们还没了解的结构，比如我们还不知道怎么去开始和结束一段输入，描述可选的字符串，或者字符串的长度内的检索。

这些是可以表示的，通过正则表达式。正则表达式一种为文本和数字进行表式的方法。我们的语法不能用正则表达式设计太多的规则，但是它可以做到精准的匹配和操作。这里有一些基础的规则介绍正则表达式：

```
.                可以匹配任何字母
a                只能匹配字符a
[abcdef]        可以匹配在字符串中的任意一个字母
[a-f]            可以匹配在a-f里的任意一个字母
a?                字符a是可要可不要
a*                可以匹配0个到多个a
a+                可以匹配1个到多个a
^                表示匹配的开始符号
$                表示匹配的结束符号
```

这些就是基本的正则表达式的符号，到目前为止了解这些就足够了，当然你想了解更多可以查看[Whole books](http://regex.learncodethehardway.org/) ，在 `mpc` 库的语法里我们可以使用正则表达式将它们放在两个 `/` 之间，比如我们使用 `Number `的规则的时候，我们可以这样来描述 `/-?[0-9]+/` 。

#### 2.7 波兰表达式语法

我们已经学习了如何使用 `mpc` 库来描述我们的波兰表达式，但是在实际运用的时候我们需要进行交互式的编程，需要使用 `while` 循环，不只是回应用户的输入，它实际上需要尝试解析我们解析器，可以使用 `mpc` 库函数来代替 `printf` ，它将为我们的 Lispy 增彩：

> ```
> /* Attempt to Parse the user Input */
> mpc_result_t r;
> if (mpc_parse("<stdin>", input, Lispy, &r)) {
>   /* On Success Print the AST */
>   mpc_ast_print(r.output);
>   mpc_ast_delete(r.output);
> } else {
>   /* Otherwise Print the Error */
>   mpc_err_print(r.error);
>   mpc_err_delete(r.error);
> }
> ```

`mpc_parse` 函数将结合我们的 Lispy ，输入的字符串为 `input` 。这段代码将解析的结果保存在 `r` 里，如果解析成功返回 1，解析失败返回 0。我们使用 `& `在 `r` 之前，关于这个用法我们之后将会介绍。

如果我们的解析是成功的，那么 `r` 中就会保存相关的结构，会在 `output` 域中，我们可以使用 `mpc_ast_print` 来打印它，然后也可以使用 `mpc_ast_delete` 来删除相关的数据。

编译好此程序后，可以做做测试，试试不同的输入，完整的程序如下，**注意 parsing.c 须放在 `/home/shiyanlou/mpc-master/` 目录下**：

**编写源程序 parsing.c：**

```
#include "mpc.h"

#ifdef _WIN32

static char buffer[2048];

char* readline(char* prompt) {
  fputs(prompt, stdout);
  fgets(buffer, 2048, stdin);
  char* cpy = malloc(strlen(buffer)+1);
  strcpy(cpy, buffer);
  cpy[strlen(cpy)-1] = '\0';
  return cpy;
}

void add_history(char* unused) {}

#else
#include <readline/readline.h>
#include <readline/history.h>
#endif


int main(int argc, char** argv) {
  /* Create Some Parsers */
  mpc_parser_t* Number   = mpc_new("number");
  mpc_parser_t* Operator = mpc_new("operator");
  mpc_parser_t* Expr     = mpc_new("expr");
  mpc_parser_t* Lispy    = mpc_new("lispy");
  
  /* Define them with the following Language */
  mpca_lang(MPCA_LANG_DEFAULT,
    "                                                     \
      number   : /-?[0-9]+/ ;                             \
      operator : '+' | '-' | '*' | '/' ;                  \
      expr     : <number> | '(' <operator> <expr>+ ')' ;  \
      lispy    : /^/ <operator> <expr>+ /$/ ;             \
    ",
    Number, Operator, Expr, Lispy);
  
  puts("Lispy Version 0.2");
  puts("Press Ctrl+c to Exit\n");
  
  while (1) {
  
    char* input = readline("lispy> ");
    add_history(input);
    
    /* Attempt to parse the user input */
    mpc_result_t r;
    if (mpc_parse("<stdin>", input, Lispy, &r)) {
      /* On success print and delete the AST */
      mpc_ast_print(r.output);
      mpc_ast_delete(r.output);
    } else {
      /* Otherwise print and delete the Error */
      mpc_err_print(r.error);
      mpc_err_delete(r.error);
    }
    
    free(input);
  }
  
  /* Undefine and delete our parsers */
  mpc_cleanup(4, Number, Operator, Expr, Lispy);
  
  return 0;
}
gcc -std=c99 -Wall parsing.c mpc.c -o parsing  -lm  -lreadline
```

然后看程序的输出是什么，能不能满足要求，比如可能像下面这样：

![2-2.7-1](https://doc.shiyanlou.com/document-uid59274labid2174timestamp1476095234179.png)

### 三、实验总结

本节实验学习 `mpc` 库的安装使用，学习了正则表达式，如何来编译我们的代码，让它变得更接近我们的语法，通过波兰表达式简单的设计了几个语法规则。

