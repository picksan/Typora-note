# 条件判断

### 一、课程简介

#### 1.1 实验简介

这是一个相当短的章节，基本上包括添加一些新的内置函数来处理比较和排序。如果你的基础比较好了，可以试试自己编写这部分内容。如果你还是觉得不确定不用担心。 跟着，我会解释我的方法。如果你觉得很好理解，继续，尝试实现比较和排序现在你的语言。

#### 1.2 实验知识点

- 编写条件判断函数
- 递归函数

#### 1.3 实验环境

- Xfce 终端
- GCC
- Gedit

#### 1.4 适合人群

本课程适合有 C 语言基础，想做练手项目的同学，可以有效的学习编写一些基础函数，如比较大小的函数，`if` 函数等，做一些有趣的事情。

#### 1.5 代码获取

你可以通过下面命令将本课程里的所有源代码下载到实验楼环境中，作为参照对比进行学习。

```bash
wget http://labfile.oss.aliyuncs.com/courses/670/conditions.c
```

**请尽量按照实验步骤自己写出 C 语言程序，请确认文件保存在目录：“/home/shiyanlou/mpc-master/” 下。**

### 二、实验步骤

我们将介绍几种在 C 中常用到的和条件判断有关的函数。包括排序，等式，`if` 函数，递归函数等。

#### 2.1 排序

为了简单起见，我将重用我们的 `number` 数据类型来表示比较的结果。 我将做一个类似于 C 的规则，任何不为 0 的数字在 `if` 语句中的值为 `true` ，而 0 总是为 `false` 。

因此，我们的排序函数有点像我们的算术函数的简化版本。 他们只会处理数字，我们只希望它们处理两个参数。

如果满足这些判断条件，逻辑很简单。 我们要返回 `lval` 为 0 或 1 ，这取决于两个输入 `lval` 之间的大小比较。 我们可以使用 C 的比较运算符来做到这一点。

像我们的算术函数，我们将使用一个单一的函数来做所有的比较:

> 首先我们检查判断条件，然后比较每个参数中的值的大小， 最后，我们将结果返回。

> ```C
> lval* builtin_gt(lenv* e, lval* a) {
>   return builtin_ord(e, a, ">");
> }
> ```

> ```C
> lval* builtin_lt(lenv* e, lval* a) {
>   return builtin_ord(e, a, "<");
> }
> ```

> ```C
> lval* builtin_ge(lenv* e, lval* a) {
>   return builtin_ord(e, a, ">=");
> }
> ```

> ```C
> lval* builtin_le(lenv* e, lval* a) {
>   return builtin_ord(e, a, "<=");
> }
> ```

#### 2.2 等式

比较的两个数大小相等将不同于排序，因为我们希望它在多个数值类型上工作，比如比较字符串，函数，表达式是不是相等。 看看一个输入是否等于一个空列表，或看看是否两个传递的函数值是相同的。 因此，我们需要定义一个函数，它可以测试两种不同类型的 `lval` 之间的相等性。

此函数实质上检查组成特定 `lval` 类型的数据的所有字段是否相等。 如果所有的字段都相等，就可以认为是相等的。 否则，如果有任何差异，它们被认为是不平等的。

> ```c
> int lval_eq(lval* x, lval* y) {
> 
>   /* Different Types are always unequal */
>   if (x->type != y->type) { return 0; }
> 
>   /* Compare Based upon type */
>   switch (x->type) {
>     /* Compare Number Value */
>     case LVAL_NUM: return (x->num == y->num);
> 
>     /* Compare String Values */
>     case LVAL_ERR: return (strcmp(x->err, y->err) == 0);
>     case LVAL_SYM: return (strcmp(x->sym, y->sym) == 0);
> 
>     /* If builtin compare, otherwise compare formals and body */
>     case LVAL_FUN:
>       if (x->builtin || y->builtin) {
>         return x->builtin == y->builtin;
>       } else {
>         return lval_eq(x->formals, y->formals)
>           && lval_eq(x->body, y->body);
>       }
> 
>     /* If list compare every individual element */
>     case LVAL_QEXPR:
>     case LVAL_SEXPR:
>       if (x->count != y->count) { return 0; }
>       for (int i = 0; i < x->count; i++) {
>         /* If any element not equal then whole list not equal */
>         if (!lval_eq(x->cell[i], y->cell[i])) { return 0; }
>       }
>       /* Otherwise lists must be equal */
>       return 1;
>     break;
>   }
>   return 0;
> }
> ```

使用这个函数，新的内建函数的相等比较很容易添加。 我们只需确保输入两个参数，并且它们是相等的。 我们将比较结果存储到一个新的 `lval` 中并返回。

> ```c
> lval* builtin_cmp(lenv* e, lval* a, char* op) {
>   LASSERT_NUM(op, a, 2);
>   int r;
>   if (strcmp(op, "==") == 0) {
>     r =  lval_eq(a->cell[0], a->cell[1]);
>   }
>   if (strcmp(op, "!=") == 0) {
>     r = !lval_eq(a->cell[0], a->cell[1]);
>   }
>   lval_del(a);
>   return lval_num(r);
> }
> 
> lval* builtin_eq(lenv* e, lval* a) {
>   return builtin_cmp(e, a, "==");
> }
> 
> lval* builtin_ne(lenv* e, lval* a) {
>   return builtin_cmp(e, a, "!=");
> }
> ```

#### 2.3 if 函数

为了使我们的比较运算符更有用，我们需要一个 `if` 函数。 这个函数有点像 C 中的三元操作。一些条件为真时，它计算一个事件，如果条件为假，则计算结果为另一个。

我们可以再次使用 `Q-Expressions` 来对一个计算进行编码。 首先，我们让用户传递一个比较的结果，然后我们让用户传递两个 `Q-Expressions` ，代表要在条件为真或假时计算代码。

> ```c
> lval* builtin_if(lenv* e, lval* a) {
>   LASSERT_NUM("if", a, 3);
>   LASSERT_TYPE("if", a, 0, LVAL_NUM);
>   LASSERT_TYPE("if", a, 1, LVAL_QEXPR);
>   LASSERT_TYPE("if", a, 2, LVAL_QEXPR);
> 
>   /* Mark Both Expressions as evaluable */
>   lval* x;
>   a->cell[1]->type = LVAL_SEXPR;
>   a->cell[2]->type = LVAL_SEXPR;
> 
>   if (a->cell[0]->num) {
>     /* If condition is true evaluate first expression */
>     x = lval_eval(e, lval_pop(a, 1));
>   } else {
>     /* Otherwise evaluate second expression */
>     x = lval_eval(e, lval_pop(a, 2));
>   }
> 
>   /* Delete argument list and return */
>   lval_del(a);
>   return x;
> }
> ```

剩下的部分就是我们去注册所有这些新的内置函数：

> ```c
> /* Comparison Functions */
> lenv_add_builtin(e, "if", builtin_if);
> lenv_add_builtin(e, "==", builtin_eq);
> lenv_add_builtin(e, "!=", builtin_ne);
> lenv_add_builtin(e, ">",  builtin_gt);
> lenv_add_builtin(e, "<",  builtin_lt);
> lenv_add_builtin(e, ">=", builtin_ge);
> lenv_add_builtin(e, "<=", builtin_le);
> ```

#### 2.4 递归函数

通过引入条件，我们实际上使我们的语言更强大。 这是因为它们有效地让我们实现了递归函数。

递归函数是函数自己调用自己的函数。 我们已经使用递归函数来执行表达式的读取和计算。 我们需要这些条件，是因为它们让我们测试希望终止递归的情况。

例如，我们可以使用条件来实现函数 `len`，它告诉我们列表中的元素数。 如果我们遇到空列表，我们只返回0。否则我们在返回输入列表的长度加 1 。

> ```c
> (fun {len l} {
>   if (== l {})
>     {0}
>     {+ 1 (len (tail l))}
> })
> ```

正如在 C 中，这种递归函数有一个很好的对称性。 首先，我们为空列表（基本案例）做一些事情。 然后，如果我们得到更大的东西，我们取出一个模块，如列表的头部，并做一些事情，然后将其与已经应用该函数的其余部分组合。

这里是另一个反转列表的函数。它先检查是否是空列表，但这次它会返回空列表。 空列表的反向还是空列表， 但是如果它得到的不是空列表，它将反转列表。

> ```c
> (fun {reverse l} {
>   if (== l {})
>     {{}}
>     {join (reverse (tail l)) (head l)}
> })
> ```

我们将使用这种技术来构建许多函数。 这是因为它将是我们语言中实现循环的主要方式。

**请参照 1.5 节的链接内容，编写源程序 conditions.c。**

**注意 conditions.c 须放在 /home/shiyanlou/mpc-master/ 目录下：**

编译后运行的结果如下：

![9-2.4-1](https://doc.shiyanlou.com/document-uid735639labid2208timestamp1527844014279.png)

### 三、实验总结

本章学习了编写比较大小的函数，if 函数，除此之外可以自己编写 || ，&& 等等操作符，都是很有趣的函数，也复习了一下递归函数的编写。