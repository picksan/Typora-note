# 更好的语言

### 一、课程简介

虽然我们对 `Lispy` 做了很多工作，但是它仍然离完全完整的生产力编程语言还有一段距离。 如果你试图使用它为任何足够大的项目，有一些你最终会遇到的问题和改进你必须做的。 解决这些问题将是什么会将它更多地纳入完全成熟的编程语言的范围。

这里有一些你可能会遇到的问题，这些问题的潜在解决方案，以及其他一些有趣的想法。

### 二、更多的类型

#### 2.1 本地类型

目前我们的语言只包含本地 C 的 `long` 和 `char *` 类型。 如果你想做任何有用的计算，这是相当限制。 我们对这些数据类型的操作也非常有限。 理想情况下，我们的语言应该包装所有的本地 C/C++ 类型，并允许操作它们的方法。 最重要的补充之一是操纵十进制数字的能力。 为此，我们可以添加 `double` 类型和相关操作。 使用多个数字类型，我们需要确保算术运算符（如 + 和 - ）可以执行相关的运算。

#### 2.2 用户定义的类型

除了添加对原生类型的支持外，最好能够给用户添加自己的新类型，就像我们在 c 中使用 `struct` 一样。使用的语法或方法取决于你怎么设计。这是一个非常重要的部分，使我们的语言可用于任何合理规模的项目。

这个任务可以给那些有想法的人试试，他们如何开发语言，他们想要的最终设计看起来像什么。

#### 2.3 列表

一些 lisps 使用方括号 [] 为列表提供文字符号。这种语法用于编写类似列表 `100（+ 10 20）300` ，在 [] 的要求为 `[100（+ 10 20）300]`。 在某些情况下，这显然更好，但它确实使用了可能用于更有趣的目的的 [] 字符。

#### 2.4 操作系统交互

编程语言的一个重要部分是打开，读取和写入文件。 比如类似在 C 中，如 `fread`，`fwrite`，`fgetc` 等。 编写实现这个功能的函数是一个相当直接的任务，但确实需要编写相当多的函数。 这就是为什么我们还没有为我们的语言做到这一点。

很多的语言都可以操作文件系统，但是我们的语言还不行。我们应该给它改变目录，列出目录中的文件和处理其他事物的能力。这是一个容易的任务，但同样需要大量的 C 函数。脚本语言一般都有这些功能，所有如果想让我们的语言用起来更方便，可以试试。

#### 2.5 哈希表

在我们用我们的语言查找变量名的时候，我们只是对环境中的所有变量进行线性搜索。 这变得越来越低效，我们已经定义的变量越多。

一个更有效的方法是实现一个哈希表。 此技术将变量名称转换为整数，并使用它来索引已知大小的数组，以找到与此符号相关联的值。 这是一个真正重要的数据结构，因为它在大量数据下有很好的性能。

任何有兴趣了解数据结构和算法的人都可以编写试试。

#### 2.6 内存池分配

我们的 Lisp 很简单，它不快。它的性能是相对于一些脚本语言，如 Python 和 Ruby 。我们程序中的大部分性能开销来自于几乎任何事情都需要我们构造和销毁lval。因此我们经常调用 `malloc`。这是一个缓慢的功能，因为它需要操作系统为我们做一些管理。在进行计算时，有很多复制，分配和释放 `lval` 类型的操作。

如果我们希望减少这种开销，我们需要降低对 `malloc` 的调用次数。这样做的一种方法是在程序开始时调用 `malloc` 一次，分配一个大的内存池。然后，我们应该将所有的 `malloc` 调用替换为一些函数，这些函数切片并切分这些内存供程序使用。这意味着我们正在模拟操作系统的一些行为，但是以更快的本地方式。这个想法被称为内存池分配，并且是游戏开发中使用的常见技术，以及其他性能敏感的应用程序。

#### 2.7 垃圾收集

其他 Lisps 分配变量不同于我们的。它们不会在环境中存储值的副本，而实际上是指向它的直接指针或引用。因为使用指针而不是副本，就像在 C 中一样，所需的开销要少得多。

如果我们存储指向值而不是副本的指针，我们需要确保指向的数据在某些其他值尝试使用之前不会被删除。执行此操作的一种方法称为标记和扫描，是监视环境中的那些值以及已分配的每个值。当一个变量放入环境中时，它和它所引用的一切都被标记。然后，当我们希望释放内存时，我们可以遍历每个分配，并删除任何未标记的内容。

这称为垃圾收集，是许多编程语言的一个组成部分。与内存池分配一样，实现垃圾收集器不需要很复杂，但它需要很认真地做，特别是如果你想让它有效率。实现这一点对于使这种语言，处理大量数据来说是实用的。

#### 2.8 尾调用优化

我们的编程语言使用递归来完成它的循环。这在概念上是一个非常聪明的方式，但实际上它是相当差。递归函数调用自己来收集计算的所有部分结果，然后将所有结果组合在一起。这是一种浪费的计算方法，对于旨在运行许多或无限迭代的循环，这是特别有问题的。

一些递归函数可以自动转换为相应的 `while` 循环，它一步一步地累加总计，而不是完全累加。这种自动转换称为尾调用优化，是对使用递归执行大量循环的程序的一个基本优化。

#### 2.9 词法定界

当我们的语言试图查找一个未定义的变量时，它会抛出一个错误。如果它能够告诉我们在运行程序之前哪些变量是未定义的，这将是更好的。这将让我们避免打字错误和其他恼人的错误。在程序运行之前找到这些问题被称为词法定界，并且使用变量定义的规则来尝试和推断哪些变量被定义，哪些变量不在程序中。

#### 2.10 静态类型

我们程序中的每个值都有一个相关的类型。这是我们知道在任何计算发生之前。我们的内置函数也只接受某些类型作为输入。我们应该能够使用这些信息来推断新的用户定义函数和值的类型。 我们还可以使用这些信息来检查在运行程序之前使用正确的类型调用函数。 这将减少在计算之前调用具有不正确类型的函数引起的任何错误。这种检查称为静态类型。